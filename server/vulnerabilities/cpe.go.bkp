package vulnerabilities

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/fleetdm/fleet/v4/pkg/download"
	"github.com/fleetdm/fleet/v4/server/contexts/ctxerr"
	"github.com/fleetdm/fleet/v4/server/fleet"
	kitlog "github.com/go-kit/kit/log"
	"github.com/go-kit/kit/log/level"
	"github.com/google/go-github/v37/github"
	"github.com/jmoiron/sqlx"
)

const (
	owner = "fleetdm"
	repo  = "nvd"
)

type NVDRelease struct {
	Etag      string
	CreatedAt time.Time
	CPEURL    string
}

var cpeSqliteRegex = regexp.MustCompile(`^cpe-.*\.sqlite\.gz$`)

func GetLatestNVDRelease(client *http.Client) (*NVDRelease, error) {
	ghclient := github.NewClient(client)
	ctx := context.Background()
	releases, _, err := ghclient.Repositories.ListReleases(ctx, owner, repo, &github.ListOptions{Page: 0, PerPage: 10})
	if err != nil {
		return nil, err
	}

	if len(releases) == 0 {
		return nil, nil
	}

	cpeURL := ""

	// TODO: get not draft release

	for _, asset := range releases[0].Assets {
		if asset != nil {
			matched := cpeSqliteRegex.MatchString(asset.GetName())
			if !matched {
				continue
			}
			cpeURL = asset.GetBrowserDownloadURL()
		}
	}

	return &NVDRelease{
		Etag:      releases[0].GetName(),
		CreatedAt: releases[0].GetCreatedAt().Time,
		CPEURL:    cpeURL,
	}, nil
}

type syncOpts struct {
	url string
}

type CPESyncOption func(*syncOpts)

func WithCPEURL(url string) CPESyncOption {
	return func(o *syncOpts) {
		o.url = url
	}
}

const cpeDatabaseFilename = "cpe.sqlite"

// DownloadCPEDatabase downloads the CPE database from the
// latest release of github.com/fleetdm/nvd to the given dbPath.
// An alternative URL can be set via the WithCPEURL option.
//
// It won't download the database if the database has already been downloaded and
// has an mtime after the release date.
func DownloadCPEDatabase(
	vulnPath string,
	client *http.Client,
	opts ...CPESyncOption,
) error {
	var o syncOpts
	for _, fn := range opts {
		fn(&o)
	}

	dbPath := filepath.Join(vulnPath, cpeDatabaseFilename)

	if o.url == "" {
		nvdRelease, err := GetLatestNVDRelease(client)
		if err != nil {
			return err
		}
		stat, err := os.Stat(dbPath)
		if err != nil {
			if !errors.Is(err, os.ErrNotExist) {
				return err
			}
		} else if !nvdRelease.CreatedAt.After(stat.ModTime()) {
			return nil
		}
		o.url = nvdRelease.CPEURL
	}

	u, err := url.Parse(o.url)
	if err != nil {
		return err
	}
	if err := download.DownloadAndExtract(client, u, dbPath); err != nil {
		return err
	}

	return nil
}

type IndexedCPEItem struct {
	ID         int     `json:"id" db:"rowid"`
	Title      string  `json:"title" db:"title"`
	Product    string  `json:"product" db:"product"`
	Vendor     string  `json:"vendor" db:"vendor"`
	Version    *string `json:"version" db:"version"`
	TargetSW   *string `json:"target_sw" db:"target_sw"`
	CPE23      string  `json:"cpe23" db:"cpe23"`
	Deprecated bool    `json:"deprecated" db:"deprecated"`
}

func cleanAppName(appName string) string {
	return strings.TrimSuffix(appName, ".app")
}

var onlyAlphaNumeric = regexp.MustCompile(`[^a-zA-Z0-9]+`)

// sanitizeMatch sanitizes the search string for sqlite fts queries. Replaces all special characters with spaces.
func santizeMatch(s string) string {
	return onlyAlphaNumeric.ReplaceAllString(s, " ")
}

var sanitizeVersionRe = regexp.MustCompile(`[^a-zA-Z0-9_-]+`)

// sanitizeVersion attempts to sanitize versions and attempt to make it dot separated.
// Eg Zoom reports version as "5.11.1 (8356)". In NVD CPE dictionary it should be 5.11.1.8356.
func sanitizeVersion(version string) string {
	parts := onlyAlphaNumeric.Split(version, -1)
	return strings.Trim(strings.Join(parts, "."), ".")
}

// TODO: add more vendors
var macOSVendors = map[string]string{
	"com.postmanlabs.mac":           "getpostman",
	"org.virtualbox.app.VirtualBox": "oracle",
}

// CPETranslations include special case translations for software that fail to match entries in the NVD CPE Dictionary
// using the standard logic. This may be due to unexpected vendor or product names.
//
// Example:
//   [
//     {
//       "match": {
//         "bundle_identifier": ["com.1password.1password"]
//       },
//       "translation": {
//         "product": ["1password"],
//         "vendor": ["agilebits"]
//       }
//     }
type CPETranslations []CPETranslationEntry

func (c CPETranslations) Translate(s *fleet.Software) (CPETranslation, bool) {
	for _, entry := range c {
		if entry.Match.Matches(s) {
			return entry.Translation, true
		}
	}

	return CPETranslation{}, false
}

type CPETranslationEntry struct {
	Match       CPETranslationMatch `json:"match"`
	Translation CPETranslation      `json:"translation"`
}

// CPETranslationMatch represents match criteria for cpe translations.
type CPETranslationMatch struct {
	Name             []string `json:"name"`
	BundleIdentifier []string `json:"bundle_identifier"`
	Source           []string `json:"source"`
}

func (c CPETranslationMatch) Matches(s *fleet.Software) bool {
	for _, name := range c.Name {
		if name != s.Name {
			return false
		}
	}
	for _, bundleID := range c.BundleIdentifier {
		if bundleID != s.BundleIdentifier {
			return false
		}
	}
	return true
}

type CPETranslation struct {
	Product  []string `json:"product"`
	Vendor   []string `json:"vendor"`
	TargetSW []string `json:"target_sw"`
}

func CPEFromSoftware(db *sqlx.DB, software *fleet.Software, translations CPETranslations) (string, error) {
	var whereSQL string
	var args []interface{}

	if translation, ok := translations.Translate(software); ok {
		// TODO: build sql to search for product vendor or target_sw
		var

	}

	name := software.Name
	version := sanitizeVersion(software.Version)
	var targetSW string

	switch software.Source {
	case "apps":
		name = cleanAppName(software.Name)

		// match on bundle identifier to reduce false positives for software with short names eg notes,
		// printer, calculator.
		// match the following target_sw
		// - mac
		// - mac_os
		// - mac_os_x
		// - macos
		whereSQL += `
    AND ? LIKE '%' || c.vendor || '%'
    AND (c.target_sw = '' OR c.target_sw LIKE 'mac%'`
		args = append(args, software.BundleIdentifier)
	case "python_packages":
		targetSW = "python"
	case "chrome_extensions":
		targetSW = "chrome"
	case "firefox_addons":
		targetSW = "firefox"
	case "safari_extensions":
		targetSW = "safari"
	case "npm_packages":
		targetSW = `"node.js"`
	case "programs":

		// match the following target_sw
		// - windows
		// - windows_10
		// - windows_7
		// - windows_8
		// - windows_8.1
		// - windows_ce
		// - windows_communication_foundation
		// - windows_integrated_security
		// - windows_mobile
		// - windows_phone
		// - windows_server
		// - windows_server_2003
		// - windows_server_2008
		// - windows_vista
		// - windows_xp
		whereSQL += `
    AND (c.target_sw = '' OR c.target_sw LIKE 'windows%')`
	}
	if targetSW != "" {
		whereSQL += `
    AND c.target_sw = ?)`
		args = append(args, targetSW)
	}

	selectSQL := fmt.Sprintf(`
SELECT
    c.rowid,
    c.title,
    c.product,
    c.vendor,
    c.version,
    c.target_sw,
    c.cpe23,
    c.deprecated
FROM
    cpe c
    JOIN cpe_search cs ON cs.rowid = c.rowid
WHERE
    cs.title MATCH ?
    AND c.version = ?%s
ORDER BY
    rank
`, whereSQL)

	// sanitize name for full text search on title
	nameTerms := onlyAlphaNumeric.ReplaceAllString(name, " ")

	args = append([]interface{}{nameTerms, version}, args...)

	var indexedCPEs []IndexedCPEItem
	err := db.Select(&indexedCPEs, selectSQL, args...)
	if err != nil {
		return "", fmt.Errorf("getting cpes for: %s: %w", software.Name, err)
	}

	// if there are any non-depecrated cpes, return the first one
	for _, item := range indexedCPEs {
		if !item.Deprecated {
			return item.CPE23, nil
		}
	}

	// try to find a non-depcrecated cpe by looking up deprecated_by
	for _, item := range indexedCPEs {
		deprecatedItem := item
		for {
			var deprecation IndexedCPEItem

			err = db.Get(
				&deprecation,
				`
SELECT
    rowid,
    title,
    product,
    vendor,
    version,
    target_sq,
    cpe23,
    deprecated
FROM
    cpe
WHERE
    cpe23 IN (
        SELECT cpe23 FROM deprecated_by d WHERE d.cpe_id = ?
    )
`,
				deprecatedItem.ID,
			)
			if err != nil {
				return "", fmt.Errorf("getting deprecation: %w", err)
			}
			if deprecation.Deprecated {
				deprecatedItem = deprecation
				continue
			}

			return deprecation.CPE23, nil
		}
	}

	return "", nil
}

func TranslateSoftwareToCPE(
	ctx context.Context,
	ds fleet.Datastore,
	vulnPath string,
	logger kitlog.Logger,
) error {
	dbPath := filepath.Join(vulnPath, cpeDatabaseFilename)

	iterator, err := ds.AllSoftwareWithoutCPEIterator(ctx)
	if err != nil {
		return ctxerr.Wrap(ctx, err, "all software iterator")
	}
	defer iterator.Close()

	db, err := sqliteDB(dbPath)
	if err != nil {
		return ctxerr.Wrap(ctx, err, "opening the cpe db")
	}
	defer db.Close()

	for iterator.Next() {
		software, err := iterator.Value()
		if err != nil {
			return ctxerr.Wrap(ctx, err, "getting value from iterator")
		}
		cpe, err := CPEFromSoftware(db, software)
		if err != nil {
			level.Error(logger).Log("software->cpe", "error translating to CPE, skipping...", "err", err)
			continue
		}
		if cpe == "" {
			// The schema for storing CVEs requires that a CPE for every software exists,
			// having that constraint in place works fine when the only source for vulnerabilities
			// is the NVD dataset but breaks down when we look at other sources for vulnerabilities (like OVAL) - this is
			// why we set a default value for CPEs.
			cpe = fmt.Sprintf("none:%d", software.ID)
		}
		err = ds.AddCPEForSoftware(ctx, *software, cpe)
		if err != nil {
			return ctxerr.Wrap(ctx, err, "inserting cpe")
		}
	}

	return nil
}
